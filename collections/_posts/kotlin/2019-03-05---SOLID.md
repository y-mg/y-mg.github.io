---
layout: post
title: "SOLID"
date: 2019-03-05T00:00:00Z
authors: ["y-mg"]
categories: [Kotlin]
description: "SRP / OCP / LSP / ISP / DIP"
thumbnail: "/assets/images/kotlin/banner/basic.png"
image: "/assets/images/kotlin/banner/basic.png"
comments: false
---

## 단일 책임 원칙 (Single Responsibility Principle)
***
클래스(객체)는 단 하나의 책임만 가져야 한다는 원칙으로, 책임의 의미는 하나의 기능으로 보면 된다.
<br/>

단일 책임 원칙의 목적은 프로그램의 유지보수성을 높이기 위한 것으로, 만일 하나의 클래스에 기능(책임)이 여러개 있다면 기능 변경(수정)이 일어났을때 수정해야할 코드가 많아지기 때문이다.
<br/>

결론적으로 단일 책임 원칙은 클래스가 한 가지 책임만 수행하다록 클래스를 따로따로 여러개 설계하라는 것이다.
<br/>
<br/>
<br/>


## 개방-폐쇄 원칙 (Open-Closed Principle)
***
확장에 열려있어야 하며, 수정에는 닫혀있어야 한다는 원칙입니다.
<br/>

기능 추가 요청이 오면 클래스를 확장을 통해 손쉽게 구현하고, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야 하는 설계 기법이다.
<br/>

결론적으로 개방-폐쇄 원칙은 추상 클래스와 상속을 통한 클래스 관계 구축을 말하는 것이다.
<br/>
<br/>
<br/>


## 리스코프 치환 원칙 (Liskov Substitution Principle)
***
자식 타입은 언제나 부모 타입으로 교체할 수 있어야 한다는 원칙이다.
<br/>

부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 프로그램 코드에서 예상치 못한 문제를 일으킬 수 있기 때문에 기본적으로 부모 메서드의 오버라이딩을 조심스럽게 해야 한다. 
<br/>

결론적으로 리스코프 치환 원칙은 다형성의 특징을 이용하기 위해 부모 타입으로 메서드를 실행해도 의도대로 실행되도록 구성을 해줘야 하는 원칙이다.
<br/>
<br/>
<br/>


## 인터페이스 분리 원칙 (Interface Segregation Principle)
***
인터페이스를 각각 용도에 맞게 잘게 분리해야한다는 설계 원칙이다.
<br/>

인터페이스를 사용하는 클라이언트를 기준으로 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것이 목적이다.
<br/>

결론적으로 인터페이스 분리 원칙은 인터페이스는 제약 없이 자유롭게 다중 상속이 가능하기 때문에, 분리할 수 있으면 분리하고 각 클래스 용도에 맞게 구현(<code style="color: #eb5657;">implements</code>)하라는 설계 원칙입니다.
<br/>
<br/>
<br/>


## 의존성 역전 원칙 (Dependency Inversion Principle)
***
객체를 참조해서 사용해야하는 상황이 생긴다면, 그 객체를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)를 참조하라는 원칙으로, 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 뜻입니다.
<br/>

의존성 역전 원칙의 목적은 각 클래스간의 결합도(`coupling`)을 낮추는 것입니다.
